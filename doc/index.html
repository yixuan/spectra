<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spectra: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spectra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Spectra Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Spectra</b> stands for <b>Sp</b>arse <b>E</b>igenvalue <b>C</b>omputation <b>T</b>oolkit as a <b>R</b>edesigned <b>A</b>RPACK. It is a C++ library for large scale eigenvalue problems, built on top of <a href="http://eigen.tuxfamily.org">Eigen</a>, an open source linear algebra library.</p>
<p><b>Spectra</b> is implemented as a header-only C++ library, whose only dependency, <b>Eigen</b>, is also header-only. Hence <b>Spectra</b> can be easily embedded in C++ projects that require calculating eigenvalues of large matrices.</p>
<p>The development page of <b>Spectra</b> is at <a href="https://github.com/yixuan/spectra">https://github.com/yixuan/spectra/</a>.</p>
<h2>Relation to ARPACK</h2>
<p><a href="http://www.caam.rice.edu/software/ARPACK/">ARPACK</a> is a software written in FORTRAN for solving large scale eigenvalue problems. The development of <b>Spectra</b> is much inspired by ARPACK, and as the whole name indicates, <b>Spectra</b> is a redesign of the ARPACK library using the C++ language.</p>
<p>In fact, <b>Spectra</b> is based on the algorithm described in the <a href="http://www.caam.rice.edu/software/ARPACK/UG/ug.html">ARPACK Users' Guide</a>, the implicitly restarted Arnoldi/Lanczos method. However, it does not use the ARPACK code, and it is <b>NOT</b> a clone of ARPACK for C++. In short, <b>Spectra</b> implements the major algorithms in ARPACK, but <b>Spectra</b> provides a completely different interface, and it does not depend on ARPACK.</p>
<h2>Common Usage</h2>
<p><b>Spectra</b> is designed to calculate a specified number ( \(k\)) of eigenvalues of a large square matrix ( \(A\)). Usually \(k\) is much less than the size of matrix ( \(n\)), so that only a few eigenvalues and eigenvectors are computed, which in general is more efficient than calculating the whole spectral decomposition. Users can choose eigenvalue selection rules to pick up the eigenvalues of interest, such as the largest \(k\) eigenvalues, or eigenvalues with largest real parts, etc.</p>
<p>To use the eigen solvers in this library, the user does not need to directly provide the whole matrix, but instead, the algorithm only requires certain operations defined on \(A\), and in the basic setting, it is simply the matrix-vector multiplication. Therefore, if the matrix-vector product \(Ax\) can be computed efficiently, which is the case when \(A\) is sparse, <b>Spectra</b> will be very powerful for large scale eigenvalue problems.</p>
<p>There are two major steps to use the <b>Spectra</b> library:</p>
<ol type="1">
<li>Define a class that implements a certain matrix operation, for example the matrix-vector multiplication \(y=Ax\) or the shift-solve operation \(y=(A-\sigma I)^{-1}x\). <b>Spectra</b> has defined a number of helper classes to quickly create such operations from a matrix object. See the documentation of <a class="el" href="classSpectra_1_1DenseGenMatProd.html">Spectra::DenseGenMatProd</a>, <a class="el" href="classSpectra_1_1DenseSymShiftSolve.html">Spectra::DenseSymShiftSolve</a>, etc.</li>
<li>Create an object of one of the eigen solver classes, for example <a class="el" href="classSpectra_1_1SymEigsSolver.html">Spectra::SymEigsSolver</a> for symmetric matrices, and <a class="el" href="classSpectra_1_1GenEigsSolver.html">Spectra::GenEigsSolver</a> for general matrices. Member functions of this object can then be called to conduct the computation and retrieve the eigenvalues and/or eigenvectors.</li>
</ol>
<p>Below is a list of the available eigen solvers in <b>Spectra</b>:</p><ul>
<li><a class="el" href="classSpectra_1_1SymEigsSolver.html">SymEigsSolver </a>: For real symmetric matrices</li>
<li><a class="el" href="classSpectra_1_1GenEigsSolver.html">GenEigsSolver </a>: For general real matrices</li>
<li><a class="el" href="classSpectra_1_1SymEigsShiftSolver.html">SymEigsShiftSolver </a>: For real symmetric matrices using the shift-and-invert mode</li>
<li><a class="el" href="classSpectra_1_1GenEigsRealShiftSolver.html">GenEigsRealShiftSolver </a>: For general real matrices using the shift-and-invert mode, with a real-valued shift</li>
<li><a class="el" href="classSpectra_1_1GenEigsComplexShiftSolver.html">GenEigsComplexShiftSolver </a>: For general real matrices using the shift-and-invert mode, with a complex-valued shift</li>
<li><a class="el" href="classSpectra_1_1SymGEigsSolver.html">SymGEigsSolver </a>: For generalized eigen solver for real symmetric matrices</li>
</ul>
<h2>Examples</h2>
<p>Below is an example that demonstrates the use of the eigen solver for symmetric matrices.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Spectra/SymEigsSolver.h&gt;</span></div><div class="line"><span class="comment">// &lt;Spectra/MatOp/DenseSymMatProd.h&gt; is implicitly included</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>Spectra;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// We are going to calculate the eigenvalues of M</span></div><div class="line">    Eigen::MatrixXd A = Eigen::MatrixXd::Random(10, 10);</div><div class="line">    Eigen::MatrixXd M = A + A.transpose();</div><div class="line"></div><div class="line">    <span class="comment">// Construct matrix operation object using the wrapper class DenseSymMatProd</span></div><div class="line">    <a class="code" href="classSpectra_1_1DenseSymMatProd.html">DenseSymMatProd&lt;double&gt;</a> op(M);</div><div class="line"></div><div class="line">    <span class="comment">// Construct eigen solver object, requesting the largest three eigenvalues</span></div><div class="line">    <a class="code" href="classSpectra_1_1SymEigsSolver.html">SymEigsSolver&lt; double, LARGEST_ALGE, DenseSymMatProd&lt;double&gt;</a> &gt; eigs(&amp;op, 3, 6);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize and compute</span></div><div class="line">    eigs.init();</div><div class="line">    <span class="keywordtype">int</span> nconv = eigs.compute();</div><div class="line"></div><div class="line">    <span class="comment">// Retrieve results</span></div><div class="line">    Eigen::VectorXd evalues;</div><div class="line">    <span class="keywordflow">if</span>(eigs.info() == <a class="code" href="group__Enumerations.html#gga6096571d2f7e1f0b62336e39d512ae4ba79882c7474aed8cd8ebddc8cd4aa5185">SUCCESSFUL</a>)</div><div class="line">        evalues = eigs.eigenvalues();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Eigenvalues found:\n&quot;</span> &lt;&lt; evalues &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Sparse matrix is supported via classes such as <a class="el" href="classSpectra_1_1SparseGenMatProd.html">Spectra::SparseGenMatProd</a> and <a class="el" href="classSpectra_1_1SparseSymMatProd.html">Spectra::SparseSymMatProd</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Eigen/SparseCore&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Spectra/GenEigsSolver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Spectra/MatOp/SparseGenMatProd.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>Spectra;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// A band matrix with 1 on the main diagonal, 2 on the below-main subdiagonal,</span></div><div class="line">    <span class="comment">// and 3 on the above-main subdiagonal</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n = 10;</div><div class="line">    Eigen::SparseMatrix&lt;double&gt; M(n, n);</div><div class="line">    M.reserve(Eigen::VectorXi::Constant(n, 3));</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line">    {</div><div class="line">        M.insert(i, i) = 1.0;</div><div class="line">        <span class="keywordflow">if</span>(i &gt; 0)</div><div class="line">            M.insert(i - 1, i) = 3.0;</div><div class="line">        <span class="keywordflow">if</span>(i &lt; n - 1)</div><div class="line">            M.insert(i + 1, i) = 2.0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Construct matrix operation object using the wrapper class SparseGenMatProd</span></div><div class="line">    <a class="code" href="classSpectra_1_1SparseGenMatProd.html">SparseGenMatProd&lt;double&gt;</a> op(M);</div><div class="line"></div><div class="line">    <span class="comment">// Construct eigen solver object, requesting the largest three eigenvalues</span></div><div class="line">    <a class="code" href="classSpectra_1_1GenEigsSolver.html">GenEigsSolver&lt; double, LARGEST_MAGN, SparseGenMatProd&lt;double&gt;</a> &gt; eigs(&amp;op, 3, 6);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize and compute</span></div><div class="line">    eigs.init();</div><div class="line">    <span class="keywordtype">int</span> nconv = eigs.compute();</div><div class="line"></div><div class="line">    <span class="comment">// Retrieve results</span></div><div class="line">    Eigen::VectorXcd evalues;</div><div class="line">    <span class="keywordflow">if</span>(eigs.info() == <a class="code" href="group__Enumerations.html#gga6096571d2f7e1f0b62336e39d512ae4ba79882c7474aed8cd8ebddc8cd4aa5185">SUCCESSFUL</a>)</div><div class="line">        evalues = eigs.eigenvalues();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Eigenvalues found:\n&quot;</span> &lt;&lt; evalues &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>And here is an example for user-supplied matrix operation class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Spectra/SymEigsSolver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>Spectra;</div><div class="line"></div><div class="line"><span class="comment">// M = diag(1, 2, ..., 10)</span></div><div class="line"><span class="keyword">class </span>MyDiagonalTen</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> rows() { <span class="keywordflow">return</span> 10; }</div><div class="line">    <span class="keywordtype">int</span> cols() { <span class="keywordflow">return</span> 10; }</div><div class="line">    <span class="comment">// y_out = M * x_in</span></div><div class="line">    <span class="keywordtype">void</span> perform_op(<span class="keywordtype">double</span> *x_in, <span class="keywordtype">double</span> *y_out)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rows(); i++)</div><div class="line">        {</div><div class="line">            y_out[i] = x_in[i] * (i + 1);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    MyDiagonalTen op;</div><div class="line">    <a class="code" href="classSpectra_1_1SymEigsSolver.html">SymEigsSolver&lt;double, LARGEST_ALGE, MyDiagonalTen&gt;</a> eigs(&amp;op, 3, 6);</div><div class="line">    eigs.init();</div><div class="line">    eigs.compute();</div><div class="line">    <span class="keywordflow">if</span>(eigs.info() == <a class="code" href="group__Enumerations.html#gga6096571d2f7e1f0b62336e39d512ae4ba79882c7474aed8cd8ebddc8cd4aa5185">SUCCESSFUL</a>)</div><div class="line">    {</div><div class="line">        Eigen::VectorXd evalues = eigs.eigenvalues();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Eigenvalues found:\n&quot;</span> &lt;&lt; evalues &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Shift-and-invert Mode</h2>
<p>When it is needed to find eigenvalues that are closest to a number \(\sigma\), for example to find the smallest eigenvalues of a positive definite matrix (in which case \(\sigma=0\)), it is advised to use the shift-and-invert mode of eigen solvers.</p>
<p>In the shift-and-invert mode, selection rules are applied to \(1/(\lambda-\sigma)\) rather than \(\lambda\), where \(\lambda\) are eigenvalues of \(A\). To use this mode, users need to define the shift-solve matrix operation. See the documentation of <a class="el" href="classSpectra_1_1SymEigsShiftSolver.html">Spectra::SymEigsShiftSolver</a> for details.</p>
<h2>License</h2>
<p><b>Spectra</b> is an open source project licensed under <a href="https://www.mozilla.org/MPL/2.0/">MPL2</a>, the same license used by <b>Eigen</b>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
